//go:build ignore

package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
)

type dayInfo struct {
	Year       int
	Day        int
	ImportPath string
	Alias      string
}

func main() {
	root, err := findRepoRoot()
	if err != nil {
		panic(err)
	}

	modulePath, err := readModulePath(root)
	if err != nil {
		panic(err)
	}

	days, err := collectDayInfo(root, modulePath)
	if err != nil {
		panic(err)
	}

	out, err := render(days)
	if err != nil {
		panic(err)
	}

	generatedPath := filepath.Join(root, "languages", "go", "cmd", "advent", "generated_days.go")
	if err := os.WriteFile(generatedPath, out, 0o644); err != nil {
		panic(err)
	}
}

func findRepoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, ".git")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", errors.New(".git directory not found")
		}
		dir = parent
	}
}

func readModulePath(root string) (string, error) {
	data, err := os.ReadFile(filepath.Join(root, "go.mod"))
	if err != nil {
		return "", err
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module")), nil
		}
	}

	return "", errors.New("module path not found in go.mod")
}

func collectDayInfo(root, modulePath string) ([]dayInfo, error) {
	entries, err := os.ReadDir(root)
	if err != nil {
		return nil, err
	}

	var days []dayInfo
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		year, err := strconv.Atoi(entry.Name())
		if err != nil {
			continue
		}

		goDir := filepath.Join(root, entry.Name(), "go")
		if info, err := os.Stat(goDir); err != nil || !info.IsDir() {
			continue
		}

		err = filepath.WalkDir(goDir, func(path string, d fs.DirEntry, walkErr error) error {
			if walkErr != nil {
				return walkErr
			}
			if !d.IsDir() {
				return nil
			}

			base := filepath.Base(path)
			if !strings.HasPrefix(base, "day") {
				return nil
			}

			dayNum, err := strconv.Atoi(strings.TrimPrefix(base, "day"))
			if err != nil {
				return nil
			}

			imp := fmt.Sprintf("%s/%s/go/%s", modulePath, entry.Name(), base)
			alias := fmt.Sprintf("y%sd%02d", entry.Name(), dayNum)

			days = append(days, dayInfo{
				Year:       year,
				Day:        dayNum,
				ImportPath: imp,
				Alias:      alias,
			})

			return fs.SkipDir
		})
		if err != nil {
			return nil, err
		}
	}

	slices.SortFunc(days, func(a, b dayInfo) int {
		if a.Year != b.Year {
			if a.Year < b.Year {
				return -1
			}
			return 1
		}
		switch {
		case a.Day < b.Day:
			return -1
		case a.Day > b.Day:
			return 1
		default:
			return 0
		}
	})

	return days, nil
}

func render(days []dayInfo) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	buf.WriteString("package main\n\n")

	buf.WriteString("import (\n")
	aliases := make(map[string]struct{})
	for _, day := range days {
		if _, exists := aliases[day.Alias]; exists {
			return nil, fmt.Errorf("duplicate alias %s", day.Alias)
		}
		aliases[day.Alias] = struct{}{}
		fmt.Fprintf(&buf, "\t%s \"%s\"\n", day.Alias, day.ImportPath)
	}
	buf.WriteString(")\n\n")

	buf.WriteString("var solutionIndex = map[int]map[int]dayRunners{\n")
	currentYear := -1
	for _, day := range days {
		if day.Year != currentYear {
			if currentYear != -1 {
				buf.WriteString("\t},\n")
			}
			currentYear = day.Year
			fmt.Fprintf(&buf, "\t%d: {\n", day.Year)
		}

		fmt.Fprintf(&buf, "\t\t%d: {\n", day.Day)
		fmt.Fprintf(&buf, "\t\t\tPart1: %s.Part1,\n", day.Alias)
		fmt.Fprintf(&buf, "\t\t\tPart2: %s.Part2,\n", day.Alias)
		buf.WriteString("\t\t},\n")
	}
	if currentYear != -1 {
		buf.WriteString("\t},\n")
	}
	buf.WriteString("}\n")

	return format.Source(buf.Bytes())
}
